{"version":3,"file":"render.js","sources":["@traceur/generated/TemplateParser/6","render.js","@traceur/generated/TemplateParser/5","@traceur/generated/TemplateParser/4","@traceur/generated/TemplateParser/12","@traceur/generated/TemplateParser/11","@traceur/generated/TemplateParser/3","@traceur/generated/TemplateParser/1","@traceur/generated/TemplateParser/2"],"names":[],"mappings":"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","sourcesContent":["define($__placeholder__0, $__placeholder__1);","import {V,normalize,cross} from \"vector\";\nimport {Ray} from \"Ray\";\nimport {radiance} from \"radiance\";\n// カメラ位置\nconst camera_position = V(50.0, 52.0, 220.0),\n    camera_dir      = V(0.0, -0.04, -1.0),\n    camera_up       = V(0.0, 1.0, 0.0);\n\n// スクリーンまでの距離\nconst screen_dist  = 40.0;\n\nexport function render(imageData, width, height, samples, y) {\n    // // ワールド座標系でのスクリーンの大きさ\n    const screen_width = 30.0 * width / height,\n        screen_height = 30.0;\n\n    // スクリーンを張るベクトル\n    const screen_x = normalize(cross(camera_dir, camera_up)).mul(screen_width),\n        screen_y = normalize(cross(screen_x, camera_dir)).mul(screen_height),\n        screen_center = camera_position.add(camera_dir.mul(screen_dist));\n\n    var ret = updateCanvas(imageData, width, y, (x, y) => {\n        let accumulated_radiance = V(0.0, 0.0, 0.0);\n\n        // 元の実装(edupt)では、supersamplesとsamplesでイテレーションしているが、\n        // samples回のイテレーションは必要ないと思われるので削除した\n        for (let sx = 0; sx < samples; ++sx) {\n            for (let sy = 0; sy < samples; ++sy) {\n\n                // rate は samples回のイテレーションで足し合わされることで合計1になる\n                // r1, r2 は rate/2 から 1 + rate/2 まで滑らかに動く\n                // samples = 2のとき, [1/4, 3/4]\n                // samples = 4のとき、[1/8, 3/8, 5/8, 7/8]\n                // つまり、 [0,1]間を等間隔にサンプリングしている\n                const rate = (1.0 / samples),\n                    r1 = sx * rate + rate / 2.0,\n                    r2 = sy * rate + rate / 2.0;\n\n                // スクリーン上での座標を計算\n                const x_screen = screen_x.mul((r1 + x) / width - 0.5),\n                    y_screen = screen_y.mul((r2 + y) / height- 0.5),\n                    screen_position = screen_center.add(x_screen.add(y_screen));\n\n                // Rayを飛ばす方向のベクトルを計算\n                const dir = normalize(screen_position.sub(camera_position));\n\n                const ray = new Ray(camera_position, dir),\n                    rad = radiance(ray, 0),\n                    difference = rad.div(Math.pow(samples, 2));\n\n                accumulated_radiance = accumulated_radiance.add(difference);\n            }\n        }\n\n        const colorArray = accumulated_radiance.x;\n        return [to_int(colorArray[0]), to_int(colorArray[1]), to_int(colorArray[2]), 255];\n    });\n\n    return ret;\n}\n\nfunction clamp(x){\n    if (x < 0.0)\n        return 0.0;\n    if (x > 1.0)\n        return 1.0;\n    return x;\n}\n\nconst gamma = 1.0/2.2;\n\nfunction to_int(x){\n    const gamma_collected = Math.pow(clamp(x), gamma);\n    return Math.floor(gamma_collected * 255 + 0.5);\n}\n\nfunction updateCanvas(imageData, width, y, fn) {\n    for (let x = 0; x < width; ++x) {\n        let color = fn(x, y);\n        for (let j = 0; j < 4; ++j) {\n            imageData.data[x*4+j] = color[j];\n        }\n    }\n\n    return {\n        imageData: imageData,\n        y: y\n    };\n}\n","function($__placeholder__0) {\n      $__placeholder__1\n    }","if (!$__placeholder__0 || !$__placeholder__1.__esModule)\n            $__placeholder__2 = { 'default': $__placeholder__3 }","$traceurRuntime.setProperty($__placeholder__0,\n          $__placeholder__1, $__placeholder__2)","$__placeholder__0[$traceurRuntime.toProperty($__placeholder__1)]","return $__placeholder__0","get $__placeholder__0() { return $__placeholder__1; }","__esModule: true"]}