{"version":3,"file":"Sphere.js","sources":["@traceur/generated/TemplateParser/6","Sphere.js","@traceur/generated/TemplateParser/5","@traceur/generated/TemplateParser/4","@traceur/generated/TemplateParser/7","@traceur/generated/TemplateParser/8","@traceur/generated/TemplateParser/3","@traceur/generated/TemplateParser/1","@traceur/generated/TemplateParser/2"],"names":[],"mappings":"AAAA,MAAM,ECAiB,cAAc,CACnB,MAAK,CACH,QAAO,CACE,WAAU,CACf,SAAQ,ECJhC,UAAS,wBAAiB;;CCA1B,KAAI,KAAkB,GAAI,EAAC,eAA4B;AAC3C,CAAA,SAAoB,EAAE,SAAS,MAAmB,CAAE,CAAA;AADhE,CACgE,KAD5D,KAAkB,GAAI,EAAC,eAA4B;AAC3C,CAAA,SAAoB,EAAE,SAAS,MAAmB,CAAE,CAAA;AADhE,CACgE,KAD5D,KAAkB,GAAI,EAAC,eAA4B;AAC3C,CAAA,SAAoB,EAAE,SAAS,MAAmB,CAAE,CAAA;AADhE,CACgE,KAD5D,KAAkB,GAAI,EAAC,eAA4B;AAC3C,CAAA,SAAoB,EAAE,SAAS,MAAmB,CAAE,CAAA;AADhE,CACgE,KAD5D,KAAkB,GAAI,EAAC,eAA4B;AAC3C,CAAA,SAAoB,EAAE,SAAS,MAAmB,CAAE,CAAA;CAAA;;;;;KFMnD,CAAA,IAAI,EAAG,KAAI;AGPpB,CAAJ,IAAI,SHYG,SAAM,OAAM,CASH,MAAM,CAAE,CAAA,QAAQ,CAAE,CAAA,QAAQ,CAAE,CAAA,KAAK,CAAE,CAAA,eAAe,CAAE;AAC5D,CAAA,OAAI,OAAO,EAAG,OAAM,CAAC;AACrB,CAAA,OAAI,SAAS,EAAG,SAAQ,CAAC;AACzB,CAAA,OAAI,SAAS,EAAG,SAAQ,CAAC;AACzB,CAAA,OAAI,MAAM,EAAG,MAAK,CAAC;AACnB,CAAA,OAAI,gBAAgB,EAAG,gBAAe,CAAC;GG1BN,AH2BpC,CG3BoC;ACAzC,CAAA,EAAC,eAAe,YAAY,CAAC,UJgExB,SAAS,CAAT,UAAU,GAAG;SACJ,CAAA,GAAG,EAAG,CAAA,IAAI,SAAS,IAAI,CAAC,GAAG,IAAI,CAAC;AAClC,CAAA,UAAC,EAAG,CAAA,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,EAAE;AAEtB,CAAA,WAAE,EAAG,CAAA,IAAI,IAAI,CAAC,CAAC,CAAE,EAAC,CAAC,CAAA,CAAG,EAAC,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,EAAG,CAAA,IAAI,IAAI,CAAC,IAAI,OAAO,CAAE,EAAC,CAAC,CAAC;CAErE,SAAI,EAAE,EAAG,IAAG,CAAE;CACV,aAAO,KAAI,CAAC;OACf;CAAA,QAEK,CAAA,OAAO,EAAG,CAAA,IAAI,KAAK,CAAC,EAAE,CAAC;AACzB,CAAA,WAAE,EAAG,CAAA,CAAC,EAAG,QAAO;AAChB,CAAA,WAAE,EAAG,CAAA,CAAC,EAAG,QAAO;CAIpB,SAAI,EAAE,EAAG,KAAI,CAAA,EAAI,CAAA,EAAE,EAAG,KAAI,CAAE;CACxB,aAAO,KAAI,CAAC;OACf;CAAA,QAEK,CAAA,QAAQ,EAAG,CAAA,EAAE,EAAG,KAAI,CAAA,CAAG,GAAE,EAAG,GAAE;AAChC,CAAA,iBAAQ,EAAG,CAAA,GAAG,IAAI,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC7C,CAAA,eAAM,EAAG,CAAA,SAAS,CAAC,QAAQ,IAAI,CAAC,IAAI,SAAS,CAAC,CAAC;CACnD,WAAO,IAAI,SAAQ,CAAC,QAAQ,CAAE,OAAM,CAAE,SAAQ,CAAC,CAAC;KACnD,MIxFiF;CCAtF;CCAA,aAAwB;CAAE,iBAAyB;KAAE;CAArD,eAAwB;CAAE,mBAAyB;KAAE;ACArD,CAAA,aAAU,CAAE,KAAI;CAAA,GFAQ;CJEnB,CFFuC,CAAC;CC0F7C","sourcesContent":["define($__placeholder__0, $__placeholder__1);","import {HitPoint} from \"Intersection\";\nimport {Ray} from \"Ray\";\nimport {Color} from \"Color\";\nimport {ReflectionType} from \"material\";\nimport {normalize} from \"vector\";\n\n// 微小な値。交差判定で使う。\nexport const kEPS = 1e-6;\n\n/**\n * 球を表すクラス。\n */\nexport class Sphere {\n    /**\n     * インスタンスを生成する。\n     * @param radius {number} 半径\n     * @param position {numeric.T} 位置を表すベクトル\n     * @param emission {Color} 放射光の色\n     * @param color {Color} 物体の色\n     * @param reflection_type {number} 表面での反射の仕方\n     */\n    constructor(radius, position, emission, color, reflection_type) {\n        this.radius = radius;\n        this.position = position;\n        this.emission = emission;\n        this.color = color;\n        this.reflection_type = reflection_type;\n    }\n\n    /*\n     intersect関数の説明(mathjaxとかのlatexを見られるところにコピペして)\n     直線と円の交差判定を以下のようにして行う。\n     半径r、中心座標\\vec{p}の円があったとする.\\\\\n     ある座標\\vec{x}がこの円の表面だとすると、以下の式が成り立つ。\\\\\n\n     ||\\vec{p} - \\vec{x}|| = r\n     \\\\\n     直線の始点(べつに直線上ならどこでもいいんですが)を\\vec{o}、方向を表す正規ベクトルを\\vec{d}、ベクトルの長さをtとする。\\\\\n     そうすると、直線上の任意の点は下式で表すことができる。\\\\\n     \\vec{o}+t \\vec{d}\n     \\\\\n     上記二つをまとめると、以下のとおり。\\\\\n     \\begin{gather}\n     ||\\vec{p}-(\\vec{o}+t \\vec{d})|| = r \\\\\n     (\\vec{p}-(\\vec{o}+t \\vec{d}))^2=r^2 \\\\\n     ((\\vec{p}-\\vec{o}) - t \\vec{d})^2=r^2 \\\\\n     \\vec{d} \\cdot \\vec{d}t^2 -2 \\vec{d} (\\vec{p}-\\vec{o})t + (\\vec{p}-\\vec{o}) \\cdot (\\vec{p}-\\vec{o}) - r^2 = 0\\\\\n     A= \\vec{d} \\cdot \\vec{d} = 1 \\\\\n     B= -2 \\vec{d} (\\vec{p}-\\vec{o}) \\\\\n     C= (\\vec{p}-\\vec{o}) \\cdot (\\vec{p}-\\vec{o}) - r^2 \\\\\n     D=B^2 - 4AC \\\\\n     = (-2\\vec{d}\\cdot(\\vec{p}-\\vec{o}))^2-4AC \\\\\n     = 4(\\vec{d}\\cdot(\\vec{p}-\\vec{o}))^2-4AC \\\\\n     D/4 = (\\vec{d}\\cdot(\\vec{p}-\\vec{o}))^2- ((\\vec{p}-\\vec{o}) \\cdot (\\vec{p}-\\vec{o}) - r^2) \\ \\ (判別式) \\\\\n     t = \\frac{B \\pm \\sqrt{D}}{2A} = \\frac{\\frac{B}{2} \\pm \\sqrt{\\frac{D}{4}}}{A}\\\\\n     = (\\vec{d}\\cdot(\\vec{p}-\\vec{o})) \\pm \\sqrt{\\frac{D}{4}}\n     \\end{gather} \\\\\n     上記、判別式と解の公式を計算している。\n     */\n    /**\n     * rayとの交差判定を行う。\n     * @param {Ray} ray\n     * @returns {HitPoint} 交差した場合、HitPointオブジェクトを返す。交差しなかった場合はnull。\n     */\n     intersect(ray) {\n        const p_o = this.position.sub(ray.org),\n            b = p_o.dot(ray.dir).x,\n            // 判別式\n            D4 = Math.pow(b, 2) - (p_o.dot(p_o).x - Math.pow(this.radius, 2));\n\n        if (D4 < 0.0) {\n            return null;\n        }\n\n        const sqrt_D4 = Math.sqrt(D4),\n            t1 = b - sqrt_D4,\n            t2 = b + sqrt_D4;\n\n        // 交差地点がRayの始点からかなり近い場所であるので\n        // この場合は、交差地点からRayが離れていくと考えて無視する。\n        if (t1 < kEPS && t2 < kEPS) {\n            return null;\n        }\n\n        const distance = t1 > kEPS ? t1 : t2,\n            position = ray.org.add(ray.dir.mul(distance)),\n            normal = normalize(position.sub(this.position));\n        return new HitPoint(distance, normal, position);\n    }\n}\n","function($__placeholder__0) {\n      $__placeholder__1\n    }","if (!$__placeholder__0 || !$__placeholder__1.__esModule)\n            $__placeholder__2 = { 'default': $__placeholder__3 }","var $__placeholder__0 = $__placeholder__1","($traceurRuntime.createClass)($__placeholder__0, $__placeholder__1, $__placeholder__2)","return $__placeholder__0","get $__placeholder__0() { return $__placeholder__1; }","__esModule: true"]}